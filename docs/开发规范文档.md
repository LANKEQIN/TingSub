# 汀阅（TingSub）开发规范文档

## 一、代码风格规范

### 1.1 TypeScript规范

#### 1.1.1 严格模式
- **启用严格模式**：在`tsconfig.json`中启用`strict: true`
- **禁止隐式any**：禁止使用`any`类型（除非必要）
- **严格空值检查**：启用`strictNullChecks: true`
- **严格函数类型**：启用`strictFunctionTypes: true`

#### 1.1.2 类型定义
```typescript
// 使用interface定义对象类型
interface User {
  id: string;
  name: string;
  email?: string;
}

// 使用type定义联合类型或交叉类型
type SubscriptionType = 'monthly' | 'yearly' | 'quarterly';

// 使用enum定义枚举
enum SubscriptionStatus {
  Active = 'active',
  Cancelled = 'cancelled',
  Expired = 'expired',
}
```

#### 1.1.3 类型注解
```typescript
// 函数参数和返回值必须有类型注解
function calculateTotal(price: number, quantity: number): number {
  return price * quantity;
}

// 组件Props必须有类型定义
interface ButtonProps {
  title: string;
  onPress: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({ title, onPress, disabled }) => {
  return <Button onPress={onPress} disabled={disabled}>{title}</Button>;
};
```

### 1.2 ESLint规范

#### 1.2.1 配置规则
```javascript
// .eslintrc.js
module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'prettier',
  ],
  rules: {
    // TypeScript规则
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    
    // React规则
    'react/prop-types': 'off',
    'react/react-in-jsx-scope': 'off',
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn',
    
    // 通用规则
    'no-console': 'warn',
    'no-debugger': 'error',
    'no-var': 'error',
    'prefer-const': 'error',
  },
};
```

#### 1.2.2 代码检查
- **提交前检查**：使用husky在提交前运行ESLint
- **自动修复**：使用`--fix`参数自动修复可修复的问题
- **忽略文件**：在`.eslintignore`中配置忽略的文件

### 1.3 Prettier规范

#### 1.3.1 配置规则
```javascript
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "always",
  "endOfLine": "lf"
}
```

#### 1.3.2 代码格式化
- **保存时格式化**：配置编辑器在保存时自动格式化
- **提交前格式化**：使用husky在提交前运行Prettier
- **忽略文件**：在`.prettierignore`中配置忽略的文件

### 1.4 命名规范

#### 1.4.1 变量命名
```typescript
// 使用驼峰命名法（camelCase）
const userName = 'John';
const isActive = true;
const subscriptionList = [];

// 常量使用全大写下划线分隔（UPPER_SNAKE_CASE）
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = 'https://api.example.com';
```

#### 1.4.2 函数命名
```typescript
// 使用驼峰命名法（camelCase）
function calculateTotal(price: number, quantity: number): number {
  return price * quantity;
}

async function fetchUserData(userId: string): Promise<User> {
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
}
```

#### 1.4.3 类命名
```typescript
// 使用帕斯卡命名法（PascalCase）
class UserService {
  async getUser(id: string): Promise<User> {
    // 实现代码
  }
}

class SubscriptionRepository {
  async findAll(): Promise<Subscription[]> {
    // 实现代码
  }
}
```

#### 1.4.4 接口命名
```typescript
// 使用帕斯卡命名法（PascalCase）
interface User {
  id: string;
  name: string;
}

interface Subscription {
  id: string;
  name: string;
  price: number;
}
```

#### 1.4.5 类型别名命名
```typescript
// 使用帕斯卡命名法（PascalCase）
type SubscriptionType = 'monthly' | 'yearly' | 'quarterly';

type UserStatus = 'active' | 'inactive' | 'suspended';
```

#### 1.4.6 枚举命名
```typescript
// 使用帕斯卡命名法（PascalCase）
enum SubscriptionStatus {
  Active = 'active',
  Cancelled = 'cancelled',
  Expired = 'expired',
}

enum ThemeMode {
  Light = 'light',
  Dark = 'dark',
  System = 'system',
}
```

### 1.5 注释规范

#### 1.5.1 注释原则
- **注释说明"为什么"而不是"是什么"**
- **保持注释简洁明了**
- **及时更新注释**
- **避免无意义的注释**

#### 1.5.2 单行注释
```typescript
// 计算订阅总费用
const total = price * quantity;

// 检查用户是否有权限访问
if (!hasPermission) {
  throw new Error('无权限访问');
}
```

#### 1.5.3 多行注释
```typescript
/**
 * 计算订阅的下次续费日期
 * @param startDate 开始日期
 * @param cycle 订阅周期
 * @returns 下次续费日期
 */
function calculateNextRenewalDate(startDate: Date, cycle: SubscriptionType): Date {
  // 实现代码
}
```

#### 1.5.4 JSDoc注释
```typescript
/**
 * 用户服务类
 * 负责用户相关的业务逻辑
 */
class UserService {
  /**
   * 获取用户信息
   * @param userId 用户ID
   * @returns 用户信息
   * @throws {Error} 用户不存在时抛出错误
   */
  async getUser(userId: string): Promise<User> {
    // 实现代码
  }
}
```

## 二、组件开发规范

### 2.1 组件定义

#### 2.1.1 函数组件
```typescript
// 使用函数组件 + Hooks，不使用类组件
import React from 'react';

interface ButtonProps {
  title: string;
  onPress: () => void;
  disabled?: boolean;
  style?: StyleProp<ViewStyle>;
}

const Button: React.FC<ButtonProps> = ({ title, onPress, disabled, style }) => {
  return (
    <TouchableOpacity
      style={[styles.button, disabled && styles.disabled, style]}
      onPress={onPress}
      disabled={disabled}
    >
      <Text style={styles.text}>{title}</Text>
    </TouchableOpacity>
  );
};

export default Button;
```

#### 2.1.2 组件Props类型定义
```typescript
// 所有组件必须有明确的Props类型定义
interface SubscriptionCardProps {
  subscription: Subscription;
  onPress: (subscription: Subscription) => void;
  onLongPress?: (subscription: Subscription) => void;
  style?: StyleProp<ViewStyle>;
}

const SubscriptionCard: React.FC<SubscriptionCardProps> = ({
  subscription,
  onPress,
  onLongPress,
  style,
}) => {
  // 组件实现
};
```

#### 2.1.3 组件默认导出
```typescript
// 组件必须导出为默认导出
const Button: React.FC<ButtonProps> = ({ title, onPress }) => {
  return <Button onPress={onPress}>{title}</Button>;
};

export default Button;
```

### 2.2 组件拆分

#### 2.2.1 组件拆分原则
- **单个组件不超过300行**
- **复杂组件拆分为子组件**
- **可复用逻辑提取为自定义Hook**

#### 2.2.2 组件拆分示例
```typescript
// 复杂组件拆分为子组件
const SubscriptionListScreen: React.FC = () => {
  const { subscriptions, loading } = useSubscriptions();

  if (loading) {
    return <Loading />;
  }

  return (
    <View style={styles.container}>
      <SubscriptionHeader />
      <SubscriptionFilter />
      <FlatList
        data={subscriptions}
        renderItem={({ item }) => <SubscriptionCard subscription={item} />}
        keyExtractor={(item) => item.id}
      />
    </View>
  );
};
```

### 2.3 组件样式

#### 2.3.1 样式组织
```typescript
// 使用StyleSheet组织样式
import { StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  button: {
    backgroundColor: '#9ACFFF',
    padding: 12,
    borderRadius: 8,
  },
  text: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '500',
  },
});
```

#### 2.3.2 样式复用
```typescript
// 提取可复用的样式
const commonStyles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  card: {
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
  },
});

// 在组件中使用
const MyComponent: React.FC = () => {
  return (
    <View style={commonStyles.container}>
      <View style={commonStyles.card}>
        {/* 内容 */}
      </View>
    </View>
  );
};
```

### 2.4 组件性能优化

#### 2.4.1 使用React.memo
```typescript
// 对于纯展示组件使用React.memo
const SubscriptionCard: React.FC<SubscriptionCardProps> = React.memo(
  ({ subscription, onPress }) => {
    return (
      <TouchableOpacity onPress={() => onPress(subscription)}>
        {/* 内容 */}
      </TouchableOpacity>
    );
  }
);
```

#### 2.4.2 使用useMemo和useCallback
```typescript
const SubscriptionListScreen: React.FC = () => {
  const { subscriptions } = useSubscriptions();

  // 使用useMemo缓存计算结果
  const totalExpense = useMemo(() => {
    return subscriptions.reduce((sum, sub) => sum + sub.price, 0);
  }, [subscriptions]);

  // 使用useCallback缓存函数
  const handlePress = useCallback((subscription: Subscription) => {
    navigation.navigate('SubscriptionDetail', { subscription });
  }, [navigation]);

  return (
    <FlatList
      data={subscriptions}
      renderItem={({ item }) => (
        <SubscriptionCard subscription={item} onPress={handlePress} />
      )}
    />
  );
};
```

#### 2.4.3 使用FlatList
```typescript
// 对于长列表使用FlatList而不是ScrollView
const SubscriptionList: React.FC = ({ subscriptions }: Props) => {
  return (
    <FlatList
      data={subscriptions}
      renderItem={({ item }) => <SubscriptionCard subscription={item} />}
      keyExtractor={(item) => item.id}
      initialNumToRender={10}
      maxToRenderPerBatch={10}
      windowSize={10}
    />
  );
};
```

## 三、状态管理规范

### 3.1 Zustand使用

#### 3.1.1 Store定义
```typescript
// src/store/subscriptionStore.ts
import { create } from 'zustand';
import { Subscription } from '../types/subscription';

interface SubscriptionStore {
  subscriptions: Subscription[];
  loading: boolean;
  error: string | null;
  
  // Actions
  setSubscriptions: (subscriptions: Subscription[]) => void;
  addSubscription: (subscription: Subscription) => void;
  updateSubscription: (id: string, subscription: Partial<Subscription>) => void;
  deleteSubscription: (id: string) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
}

export const useSubscriptionStore = create<SubscriptionStore>((set) => ({
  subscriptions: [],
  loading: false,
  error: null,
  
  setSubscriptions: (subscriptions) => set({ subscriptions }),
  
  addSubscription: (subscription) =>
    set((state) => ({
      subscriptions: [...state.subscriptions, subscription],
    })),
  
  updateSubscription: (id, subscription) =>
    set((state) => ({
      subscriptions: state.subscriptions.map((sub) =>
        sub.id === id ? { ...sub, ...subscription } : sub
      ),
    })),
  
  deleteSubscription: (id) =>
    set((state(state) => ({
      subscriptions: state.subscriptions.filter((sub) => sub.id !== id),
    })),
  
  setLoading: (loading) => set({ loading }),
  setError: (error) => set({ error }),
}));
```

#### 3.1.2 Store使用
```typescript
// 在组件中使用Store
const SubscriptionListScreen: React.FC = () => {
  const { subscriptions, loading, error, fetchSubscriptions } = useSubscriptionStore();

  useEffect(() => {
    fetchSubscriptions();
  }, [fetchSubscriptions]);

  if (loading) {
    return <Loading />;
  }

  if (error) {
    return <Error message={error} />;
  }

  return (
    <FlatList
      data={subscriptions}
      renderItem={({ item }) => <SubscriptionCard subscription={item} />}
    />
  );
};
```

### 3.2 本地状态使用

#### 3.2.1 useState使用
```typescript
// 简单的本地状态使用useState
const SubscriptionForm: React.FC = () => {
  const [name, setName] = useState('');
  const [price, setPrice] = useState(0);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async () => {
    setLoading(true);
    try {
      await createSubscription({ name, price });
    } finally {
      setLoading(false);
    }
  };

  return (
    <View>
      <TextInput value={name} onChangeText={setName} />
      <TextInput value={price.toString()} onChangeText={(text) => setPrice(Number(text))} />
      <Button onPress={handleSubmit} loading={loading} />
    </View>
  );
};
```

#### 3.2.2 useReducer使用
```typescript
// 复杂的本地状态使用useReducer
interface FormState {
  name: string;
  price: number;
  category: string;
  errors: Record<string, string>;
}

type FormAction =
  | { type: 'SET_NAME'; payload: string }
  | { type: 'SET_PRICE'; payload: number }
  | { type: 'SET_CATEGORY'; payload: string }
  | { type: 'SET_ERROR'; payload field: string; message: string }
  | { type: 'RESET' };

const formReducer = (state: FormState, action: FormAction): FormState => {
  switch (action.type) {
    case 'SET_NAME':
      return { ...state, name: action.payload };
    case 'SET_PRICE':
      return { ...state, price: action.payload };
    case 'SET_CATEGORY':
      return { ...state, category: action.payload };
    case 'SET_ERROR':
      return { ...state, errors: { ...state.errors, [action.payload.field]: action.payload.message } };
    case 'RESET':
      return initialState;
    default:
      return state;
  }
};

const SubscriptionForm: React.FC = () => {
  const [state, dispatch] = useReducer(formReducer, initialState);

  // 使用状态
};
```

### 3.3 状态管理原则

#### 3.3.1 状态选择原则
- **全局状态**：使用Zustand管理
- **组件本地状态**：使用useState管理
- **复杂状态**：使用useReducer管理
- **避免过度使用Context**：优先使用Zustand

#### 3.3.2 状态更新原则
- **不可变更新**：始终返回新的状态对象
- **批量更新**：使用set函数的回调形式进行批量更新
- **异步更新**：异步操作在action中处理

## 四、数据处理规范

### 4.1 Repository层使用

#### 4.1.1 数据操作原则
- **所有数据操作必须通过Repository层**
- **数据验证在Repository层进行**
- **敏感数据必须加密存储**
- **异步操作必须使用async/await**

#### 4.1.2 Repository实现
```typescript
// src/repositories/SubscriptionRepository.ts
import { BaseRepository } from './BaseRepository';
import { Subscription } from '../types/subscription';

export class SubscriptionRepository extends BaseRepository<Subscription> {
  /**
   * 创建订阅
   */
  async create(subscription: Omit<Subscription, 'id' | 'createdAt' | 'updatedAt'>): Promise<Subscription> {
    return this.executeOperation(async () => {
      // 验证数据
      const validatedData = ValidationUtils.validateSubscription(subscription);

      // 生成ID和时间戳
      const newSubscription: Subscription = {
        ......validatedData,
        id: generateUUID(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      // 保存到数据库
      return this.realm.write(() => {
        return this.realm.create('Subscription', newSubscription);
      });
    }, '创建订阅失败');
  }

  /**
   * 获取订阅
   */
  async getById(id: string): Promise<Subscription | null> {
    return this.executeOperation(() => {
      return this.realm.objectForPrimaryKey('Subscription', id) || null;
    }, '获取订阅失败');
  }

  /**
   * 更新订阅
   */
  async update(id: string, subscription: Partial<Subscription>): Promise<Subscription> {
    return this.executeOperation(async () => {
      // 查找现有订阅
      const existing = await this.findOrThrow(id, '订阅');

      // 合并数据
      const mergedData = { ...existing, ...subscription };

      // 验证合并后的数据
      const validatedData = ValidationUtils.validateSubscription(mergedData);

      // 更新数据库
      return this.realm.write(() => {
        const updated = this.realm.create('Subscription', {
          ...validatedData,
          updatedAt: new Date(),
        }, true);
        return updated;
      });
    }, '更新订阅失败');
  }

  /**
   * 删除订阅
   */
  async delete(id: string): Promise<void> {
    return this.executeOperation(async () => {
      // 查找订阅
      await this.findOrThrow(id, '订阅');

      // 删除订阅
      this.realm.write(() => {
        const subscription = this.realm.objectForPrimaryKey('Subscription', id);
        if (subscription) {
          this.realm.delete(subscription);
        }
      });
    }, '删除订阅失败');
  }
}
```

### 4.2 数据验证规范

#### 4.2.1 验证原则
- **所有用户输入必须经过验证**
- **使用Yup进行数据验证**
- **验证失败时抛出明确的错误信息**

#### 4.2.2 验证实现
```typescript
// src/utils/validationUtils.ts
import * as yup from 'yup';

// 订阅信息验证Schema
export const subscriptionSchema = yup.object().shape({
  id: yup.string().required('订阅ID不能为空').uuid('订阅ID格式不正确'),
  name: yup.string()
    .required('订阅名称不能为空')
    .min(1, '订阅名称至少1个字符')
    .max(100, '订阅名称最多100个字符'),
  price: yup.number()
    .required('订阅费用不能为空')
    .positive('订阅费用必须大于0')
    .max(999999.99, '订阅费用超出范围'),
  type: yup.string()
    .required('订阅周期不能为空')
    .oneOf(['monthly', 'yearly', 'quarterly', 'weekly', 'one-time'], '订阅周期值不正确'),
});

// 验证工具类
export class ValidationUtils {
  /**
   * 验证订阅数据
   */
  static validateSubscription(data: any): Subscription {
    try {
      return subscriptionSchema.validateSync(data, { abortEarly: false });
    } catch (error) {
      if (error instanceof yup.ValidationError) {
        throw new ValidationError('订阅数据验证失败', error.errors);
      }
      throw error;
    }
  }
}
```

### 4.3 数据加密规范

#### 4.3.1 加密原则
- **敏感数据必须加密存储**
- **使用AES-256加密算法**
- **加密密钥安全存储**

#### 4.3.2 加密实现
```typescript
// src/utils/encryptionUtils.ts
import CryptoJS from 'crypto-js';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || 'default-key';

export class EncryptionUtils {
  /**
   * 加密数据
   */
  static encrypt(data: string): string {
    return CryptoJS.AES.encrypt(data, ENCRYPTION_KEY).toString();
  }

  /**
   * 解密数据
   */
  static decrypt(encryptedData: string): string {
    const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  }

  /**
   * 加密对象
   */
  static encryptObject(obj: any): string {
    const jsonString = JSON.stringify(obj);
    return this.encrypt(jsonString);
  }

  /**
   * 解密对象
   */
  static decryptObject<T>(encryptedData: string): T {
    const jsonString = this.decrypt(encryptedData);
    return JSON.parse(jsonString) as T;
  }
}
```

## 五、错误处理规范

### 5.1 错误处理原则

#### 5.1.1 错误处理原则
- **所有异步操作必须有错误处理**
- **使用try-catch捕获异常**
- **向用户展示友好的错误提示**
- **记录错误日志**

#### 5.1.2 错误类型定义
```typescript
// 错误类型枚举
export enum ErrorType {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
  NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
  PERMISSION_ERROR = 'PERMISSION_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}

// 自定义错误基类
export class AppError extends Error {
  constructor(
    message: string,
    public type: ErrorType,
    public code?: string,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// 验证错误
export class ValidationError extends AppError {
  constructor(message: string, details?: string[]) {
    super(message, ErrorType.VALIDATION_ERROR, 'VALIDATION_FAILED', details);
    this.name = 'ValidationError';
  }
}

// 数据库错误
export class DatabaseError extends AppError {
  constructor(message: string, details?: any) {
    super(message, ErrorType.DATABASE_ERROR, 'DATABASE_ERROR', details);
    this.name = 'DatabaseError';
  }
}

// 网络错误
export class NetworkError extends AppError {
  constructor(message: string, details?: any) {
    super(message, ErrorType.NETWORK_ERROR, 'NETWORK_ERROR', details);
    this.name = 'NetworkError';
  }
}
```

### 5.2 错误处理实现

#### 5.2.1 错误处理工具
```typescript
// src/utils/errorHandler.ts
import { Alert } from 'react-native';

export class ErrorHandler {
  /**
   * 处理错误并返回用户友好的错误信息
   */
  static handleError(error: unknown): string {
    if (error instanceof AppError) {
      return this.getUserFriendlyMessage(error);
    } else if (error instanceof Error) {
      return error.message;
    } else {
      return '发生未知错误，请稍后重试';
    }
  }

  /**
   * 获取用户友好的错误信息
   */
  private static getUserFriendlyMessage(error: AppError): string {
    switch (error.type) {
      case ErrorType.VALIDATION_ERROR:
        return error.message || '输入数据不正确，请检查后重试';
      case ErrorType.DATABASE_ERROR:
        return '数据保存失败，请稍后重试';
      case ErrorType.NETWORK_ERROR:
        return '网络连接失败，请检查网络后重试';
      case ErrorType.NOT_FOUND_ERROR:
        return error.message || '请求的资源不存在';
      case ErrorType.PERMISSION_ERROR:
        return error.message || '没有权限执行此操作';
      default:
        return '发生未知错误，请稍后重试';
    }
  }

  /**
   * 显示错误提示
   */
  static showError(error: unknown): void {
    const message = this.handleError(error);
    Alert.alert('错误', message);
  }
}
```

#### 5.2.2 错误处理Hook
```typescript
// src/hooks/useErrorHandler.ts
import { useCallback } from 'react';
import { Alert } from 'react-native';

export const useErrorHandler = () => {
  const handleError = useCallback((error: unknown) => {
    ErrorHandler.logError(error);
    ErrorHandler.showError(error);
  }, []);

  const handleAsyncError = useCallback(async (
    asyncFn: () => Promise<void>,
    onSuccess?: () => void
  ) => {
    try {
      await asyncFn();
      onSuccess?.();
    } catch (error) {
      handleError(error);
    }
  }, [handleError]);

  return { handleError, handleAsyncError };
};
```

#### 5.2.3 错误处理示例
```typescript
// 在组件中使用错误处理
const SubscriptionForm: React.FC = () => {
  const { handleAsyncError } = useErrorHandler();

  const handleSubmit = () => {
    handleAsyncError(
      async () => {
        await subscriptionRepository.create(subscriptionData);
      },
      () => {
        Alert.alert('成功', '订阅创建成功');
      }
    );
  };

  return <Button onPress={handleSubmit}>提交</Button>;
};
```

## 六、安全性规范

### 6.1 数据安全

#### 6.1.1 数据加密
- **不在代码中硬编码敏感信息**
- **使用环境变量存储配置**
- **用户输入必须进行验证和清理**
- **本地数据使用加密存储**

#### 6.1.2 环境变量使用
```typescript
// src/config/env.ts
export const ENV = {
  // 应用环境
  NODE_ENV: process.env.NODE_ENV || 'development',
  
  // 应用配置
  APP_NAME: '汀阅',
  APP_VERSION: '1.0.0',
  
  // 数据库配置
  REALM_ENCRYPTION_KEY: process.env.REALM_ENCRYPTION_KEY || '',
  
  // 功能开关
  ENABLE_CLOUD_SYNC: process.env.ENABLE_CLOUD_SYNC === 'true',
  ENABLE_ANALYTICS: process.env.ENABLE_ANALYTICS === 'true',
};
```

### 6.2 权限管理

#### 6.2.1 权限申请原则
- **仅申请必要的系统权限**
- **在申请权限时向用户说明用途**
- **动态权限申请，在需要时才申请**

#### 6.2.2 权限申请实现
```typescript
// src/utils/permissionUtils.ts
import { PermissionsAndroid, Platform } from 'react-native';

export class PermissionUtils {
  /**
   * 请求通知权限
   */
  static async requestNotificationPermission(): Promise<boolean> {
    if (Platform.OS === 'android') {
      try {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS
        );
        return granted === PermissionsAndroid.RESULTS.GRANTED;
      } catch (error) {
        console.error('请求通知权限失败', error);
        return false;
      }
    }
    return true;
  }

  /**
   * 检查通知权限
   */
  static async checkNotificationPermission(): Promise<boolean> {
    if (Platform.OS === 'android') {
      const granted = await PermissionsAndroid.check(
        PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS
      );
      return granted;
    }
    return true;
  }
}
```

## 七、导航规范

### 7.1 导航配置

#### 7.1.1 导航类型定义
```typescript
// src/navigation/types.ts
export type RootStackParamList = {
  Home: undefined;
  SubscriptionList: undefined;
  SubscriptionDetail: { subscriptionId: string };
  AddSubscription: undefined;
  EditSubscription: { subscriptionId: string };
  CategoryList: undefined;
  Statistics: undefined;
  Settings: undefined;
};

export type TabParamList = {
  Home: undefined;
  Category: undefined;
  Statistics: undefined;
  Settings: undefined;
};
```

#### 7.1.2 导航配置实现
```typescript
// src/navigation/AppNavigator.tsx
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

const Stack = createStackNavigator<RootStackParamList>();
const Tab = createBottomTabNavigator<TabParamList>();

const TabNavigator = () => {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={HomeScreen} options={{ title: '首页' }} />
      <Tab.Screen name="Category" component={CategoryListScreen} options={{ title: '分类' }} />
      <Tab.Screen name="Statistics" component={StatisticsScreen} options={{ title: '统计' }} />
      <Tab.Screen name="Settings" component={SettingsScreen} options={{ title: '设置' }} />
    </Tab.Navigator>
  );
};

const AppNavigator = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={TabNavigator} options={{ headerShown: false }} />
        <Stack.Screen name="SubscriptionDetail" component={SubscriptionDetailScreen} options={{ title: '订阅详情' }} />
        <Stack.Screen name="AddSubscription" component={AddSubscriptionScreen} options={{ title: '添加订阅' }} />
        <Stack.Screen name="EditSubscription" component={EditSubscriptionScreen} options={{ title: '编辑订阅' }} />
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default AppNavigator;
```

### 7.2 导航使用

#### 7.2.1 页面导航
```typescript
// 在组件中使用导航
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RootStackParamList } from '../navigation/types';

type NavigationProp = NativeStackNavigationProp<RootStackParamList>;

const SubscriptionListScreen: React.FC = () => {
  const navigation = useNavigation<NavigationProp>();

  const handlePress = (subscriptionId: string) => {
    navigation.navigate('SubscriptionDetail', { subscriptionId });
  };

  const handleAdd = () => {
    navigation.navigate('AddSubscription');
  };

  return (
    <View>
      <Button onPress={handleAdd}>添加订阅</Button>
      <FlatList
        data={subscriptions}
        renderItem={({ item }) => (
          <SubscriptionCard subscription={item} onPress={() => handlePress(item.id)} />
        )}
      />
    </View>
  );
};
```

#### 7.2.2 路由参数传递
```typescript
// 接收路由参数
const SubscriptionDetailScreen: React.FC = () => {
  const route = useRoute<RouteProp<RootStackParamList, 'SubscriptionDetail'>>();
  const { subscriptionId } = route.params;

  const { subscription, loading } = useSubscription(subscriptionId);

  if (loading) {
    return <Loading />;
  }

  return (
    <View>
      <Text>{subscription?.name}</Text>
      <Text>{subscription?.price}</Text>
    </View>
  );
};
```

## 八、日期处理规范

### 8.1 日期处理原则

#### 8.1.1 日期处理原则
- **使用date-fns处理日期**
- **日期格式统一使用ISO格式存储**
- **显示时根据用户语言环境格式化**

#### 8.1.2 日期处理实现
```typescript
// src/utils/dateUtils.ts
import { format, parseISO, addMonths, addYears, differenceInDays } from 'date-fns';
import { zhCN } from 'date-fns/locale';

export class DateUtils {
  /**
   * 格式化日期为显示格式
   */
  static formatDate(date: Date | string, formatStr: string = 'yyyy-MM-dd'): string {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    return format(dateObj, formatStr, { locale: zhCN });
  }

  /**
   * 格式化日期为相对时间
   */
  static formatRelativeTime(date: Date | string): string {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    const now = new Date();
    const days = differenceInDays(dateObj, now);

    if (days === 0) {
      return '今天';
    } else if (days === 1) {
      return '明天';
    } else if (days === -1) {
      return '昨天';
    } else if (days > 0 && days <= 7) {
      return `${days}天后`;
    } else if (days < 0 && days >= -7) {
      return `${Math.abs(days)}天前`;
    } else {
      return this.formatDate(dateObj);
    }
  }

  /**
   * 计算下次续费日期
   */
  static calculateNextRenewalDate(startDate: Date, cycle: string): Date {
    switch (cycle) {
      case 'monthly':
        return addMonths(startDate, 1);
      case 'quarterly':
        return addMonths(startDate, 3);
      case 'yearly':
        return addYears(startDate, 1);
      default:
        return startDate;
    }
  }

  /**
   * 检查日期是否过期
   */
  static isExpired(date: Date | string): boolean {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    return dateObj < new Date();
  }

  /**
   * 检查日期是否即将到期
   */
  static isExpiringSoon(date: Date | string, days: number = 7): boolean {
    const dateObj = typeof date === 'string' ? parseISO(date) : date;
    const daysUntilExpiry = differenceInDays(dateObj, new Date());
    return daysUntilExpiry >= 0 && daysUntilExpiry <= days;
  }
}
```

## 九、Git提交规范

### 9.1 Commit Message格式

#### 9.1.1 Commit Message格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### 9.1.2 Type类型
- **feat**：新功能
- **fix**：修复bug
- **docs**：文档更新
- **style**：代码格式调整
- **refactor**：代码重构
- **perf**：性能优化
- **test**：测试相关
- **chore**：构建过程或辅助工具的变动

#### 9.1.3 Commit Message示例
```
feat(subscription): 添加订阅创建功能

- 实现订阅创建表单
- 添加数据验证
- 添加错误处理

Closes #123
```

```
fix(subscription): 修复订阅列表加载问题

修复了订阅列表在首次加载时无法显示的问题

Fixes #456
```

### 9.2 Git工作流

#### 9.2.1 分支策略
- **main**：主分支，用于生产环境
- **SY01***：试验分支，用于所有的测试

#### 9.2.2 分支命名规范
```
feature/subscription-management
bugfix/notification-error
release/v1.0.0
```

## 十、代码审查规范

### 10.1 代码审查原则

#### 10.1.1 审查原则
- **代码必须经过审查才能合并**
- **至少一人审查通过才能合并**
- **审查者应关注代码质量、可维护性、安全性**

#### 10.1.2 审查清单
- [ ] 代码符合项目规范
- [ ] 代码有适当的注释
- [ ] 代码有适当的错误处理
- [ ] 代码没有安全漏洞
- [ ] 代码性能良好
- [ ] 代码有适当的测试

### 10.2 Pull Request规范

#### 10.2.1 PR标题格式
```
<type>: <subject>

示例：
feat: 添加订阅管理功能
fix: 修复通知推送问题
```

#### 10.2.2 PR描述模板
```markdown
## 变更说明
简要描述本次变更的内容

## 变更类型
- [ ] 新功能
- [ ] Bug修复
- [ ] 性能优化
- [ ] 代码重构
- [ ] 文档更新
- [ ] 其他

## 测试情况
- [ ] 已添加测试
- [ ] 已通过测试
- [ ] 已手动测试

## 相关Issue
Closes #123

## 截图（如有UI变更）
[截图]
```

## 十一、附录

### 11.1 代码规范速查表
| 规范类型 | 规范内容 | 说明 |
| --- | --- | --- |
| TypeScript | 严格模式 | 启用strict模式 |
| 命名规范 | 驼峰命名法 | 变量、函数使用camelCase |
| 命名规范 | 帕斯卡命名法 | 类、接口使用PascalCase |
| 命名规范 | 全大写下划线 | 常量使用UPPER_SNAKE_CASE |
| 组件规范 | 函数组件 | 使用函数组件+Hooks |
| 状态管理 | Zustand | 全局状态使用Zustand |
| 数据操作 | Repository层 | 数据操作通过Repository层 |
| 错误处理 | try-catch | 异步操作必须有错误处理 |
| 安全性规范 | 数据加密 | 敏感数据必须加密存储 |

### 11.2 参考资料
- 《TypeScript 官方文档》
- 《React Native 官方文档》
- 《Zustand 官方文档》
- 《date-fns 官方文档》
- 《ESLint 官方文档》
- 《Prettier 官方文档》
