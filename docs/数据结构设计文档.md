# 汀阅（TingSub）数据结构设计文档

## 一、数据结构概述

### 1.1 设计原则
1. **完整性**：覆盖所有业务需求的数据字段
2. **一致性**：数据结构在整个应用中保持一致
3. **可扩展性**：便于后续功能扩展和数据字段添加
4. **性能优化**：考虑数据查询和存储的性能
5. **数据安全**：敏感数据加密存储

### 1.2 数据存储方案
- **本地存储**：使用Realm数据库存储结构化数据，AsyncStorage存储简单键值对数据
- **云端存储**：当前版本暂不考虑，后续版本将引入云端存储实现数据同步

## 二、核心数据模型

### 2.1 用户信息模型
```typescript
interface User {
  id: string; // 用户唯一标识，UUID生成
  username: string; // 用户名
  email?: string; // 邮箱（可选，用于后续云端同步）
  avatar?: string; // 头像本地路径或云端URL
  theme: 'light' | 'dark' | 'system'; // 主题设置
  currency: string; // 货币类型，默认'CNY'
  reminderSettings: ReminderSettings; // 提醒设置
  createdAt: Date; // 创建时间
  updatedAt: Date; // 最后更新时间
}
```

### 2.2 提醒设置模型
```typescript
interface ReminderSettings {
  enabled: boolean; // 是否启用提醒
  advanceDays: number; // 提前提醒天数，默认3天
  repeatInterval: 'none' | 'daily' | 'weekly'; // 重复提醒间隔
  notificationChannels: NotificationChannel[]; // 通知渠道
}

interface NotificationChannel {
  type: 'local'; // 通知类型，当前仅支持本地推送
  enabled: boolean; // 是否启用该渠道
  sound: boolean; // 是否开启声音
  vibration: boolean; // 是否开启震动
}
```

### 2.3 订阅信息模型
```typescript
interface Subscription {
  id: string; // 订阅唯一标识，UUID生成
  userId: string; // 关联用户ID
  name: string; // 订阅名称（如Netflix）
  description?: string; // 订阅描述
  categoryId: string; // 关联分类ID
  tags: string[]; // 标签列表
  type: 'monthly' | 'yearly' | 'quarterly' | 'weekly' | 'one-time'; // 订阅周期
  price: number; // 订阅费用
  currency: string; // 货币类型，默认'CNY'
  billingDate: Date; // 计费日期
  startDate: Date; // 开始日期
  endDate?: Date; // 到期日期（可选，终身订阅为空）
  renewalDate: Date; // 下次续费日期
  autoRenew: boolean; // 是否自动续费
  status: 'active' | 'cancelled' | 'expired'; // 订阅状态
  platform: string; // 订阅平台（如App Store、官网）
  paymentMethod: string; // 支付方式（如支付宝、微信支付）
  notes?: string; // 备注信息
  createdAt: Date; // 创建时间
  updatedAt: Date; // 最后更新时间
}
```

### 2.4 分类信息模型
```typescript
interface Category {
  id: string; // 分类唯一标识，UUID生成
  userId: string; // 关联用户ID
  name: string; // 分类名称（如视频、音乐）
  description?: string; // 分类描述
  color: string; // 分类颜色，十六进制格式（如'#FF0000'）
  icon: string; // 分类图标名称（对应React Native Vector Icons）
  isDefault: boolean; // 是否为系统预设分类
  createdAt: Date; // 创建时间
  updatedAt: Date; // 最后更新时间
}
```

### 2.5 标签信息模型
```typescript
interface Tag {
  id: string; // 标签唯一标识，UUID生成
  userId: string; // 关联用户ID
  name: string; // 标签名称（如'常用'、'娱乐'）
  color: string; // 标签颜色，十六进制格式
  createdAt: Date; // 创建时间
  updatedAt: Date; // 最后更新时间
}
```

### 2.6 提醒历史模型
```typescript
interface ReminderHistory {
  id: string; // 提醒历史唯一标识，UUID生成
  userId: string; // 关联用户ID
  subscriptionId: string; // 关联订阅ID
  reminderType: 'expiration' | 'renewal'; // 提醒类型
  reminderDate: Date; // 提醒日期
  status: 'sent' | 'viewed' | 'dismissed'; // 提醒状态
  createdAt: Date; // 创建时间
}
```

### 2.7 统计数据模型
```typescript
interface Statistics {
  id: string; // 统计数据唯一标识，UUID生成
  userId: string; // 关联用户ID
  period: 'daily' | 'weekly' | 'monthly' | 'yearly'; // 统计周期
  startDate: Date; // 统计开始日期
  endDate: Date; // 统计结束日期
  totalExpense: number; // 总支出
  subscriptionCount: number; // 订阅数量
  categoryStats: CategoryStat[]; // 分类统计
  typeStats: TypeStat[]; // 周期类型统计
  createdAt: Date; // 创建时间
  updatedAt: Date; // 最后更新时间
}

interface CategoryStat {
  categoryId: string; // 分类ID
  categoryName: string; // 分类名称
  expense: number; // 支出金额
  count: number; // 订阅数量
}

interface TypeStat {
  type: 'monthly' | 'yearly' | 'quarterly' | 'weekly' | 'one-time'; // 订阅周期类型
  expense: number; // 支出金额
  count: number; // 订阅数量
}
```

## 三、预设数据

### 3.1 预设分类
```typescript
const defaultCategories: Category[] = [
  {
    id: 'category-1',
    userId: 'default',
    name: '视频',
    description: '视频流媒体服务',
    color: '#FF0000',
    icon: 'movie',
    isDefault: true,
    createdAt: new Date(),
    updatedAt: new Date()
  },
  {
    id: 'category-2',
    userId: 'default',
    name: '音乐',
    description: '音乐流媒体服务',
    color: '#1DB954',
    icon: 'music-note',
    isDefault: true,
    createdAt: new Date(),
    updatedAt: new Date()
  },
  {
    id: 'category-3',
    userId: 'default',
    name: '工具',
    description: '生产力工具软件',
    color: '#007AFF',
    icon: 'wrench',
    isDefault: true,
    createdAt: new Date(),
    updatedAt: new Date()
  },
  {
    id: 'category-4',
    userId: 'default',
    name: '教育',
    description: '在线教育课程',
    color: '#5856D6',
    icon: 'book',
    isDefault: true,
    createdAt: new Date(),
    updatedAt: new Date()
  },
  {
    id: 'category-5',
    userId: 'default',
    name: '生活',
    description: '生活服务订阅',
    color: '#34C759',
    icon: 'heart',
    isDefault: true,
    createdAt: new Date(),
    updatedAt: new Date()
  }
];
```

### 3.2 预设标签
```typescript
const defaultTags: Tag[] = [
  {
    id: 'tag-1',
    userId: 'default',
    name: '常用',
    color: '#FF9500',
    createdAt: new Date(),
    updatedAt: new Date()
  },
  {
    id: 'tag-2',
    userId: 'default',
    name: '娱乐',
    color: '#AF52DE',
    createdAt: new Date(),
    updatedAt: new Date()
  },
  {
    id: 'tag-3',
    userId: 'default',
    name: '工作',
    color: '#00C7BE',
    createdAt: new Date(),
    updatedAt: new Date()
  },
  {
    id: 'tag-4',
    userId: 'default',
    name: '学习',
    color: '#FF3B30',
    createdAt: new Date(),
    updatedAt: new Date()
  }
];
```

## 四、数据库设计

### 4.1 Realm数据库架构
#### 4.1.1 数据模型定义
```typescript
// User模型
class User extends Realm.Object<User> {
  id!: string;
  username!: string;
  email?: string;
  avatar?: string;
  theme!: 'light' | 'dark' | 'system';
  currency!: string;
  reminderSettings!: ReminderSettings;
  createdAt!: Date;
  updatedAt!: Date;

  static schema: Realm.ObjectSchema = {
    name: 'User',
    primaryKey: 'id',
    properties: {
      id: 'string',
      username: 'string',
      email: 'string?',
      avatar: 'string?',
      theme: 'string',
      currency: 'string',
      reminderSettings: 'ReminderSettings',
      createdAt: 'date',
      updatedAt: 'date'
    }
  };
}

// Subscription模型
class Subscription extends Realm.Object<Subscription> {
  id!: string;
  userId!: string;
  name!: string;
  description?: string;
  categoryId!: string;
  tags!: string[];
  type!: string;
  price!: number;
  currency!: string;
  billingDate!: Date;
  startDate!: Date;
  endDate?: Date;
  renewalDate!: Date;
  autoRenew!: boolean;
  status!: string;
  platform!: string;
  paymentMethod!: string;
  notes?: string;
  createdAt!: Date;
  updatedAt!: Date;

  static schema: Realm.ObjectSchema = {
    name: 'Subscription',
    primaryKey: 'id',
    properties: {
      id: 'string',
      userId: 'string',
      name: 'string',
      description: 'string?',
      categoryId: 'string',
      tags: 'string[]',
      type: 'string',
      price: 'double',
      currency: 'string',
      billingDate: 'date',
      startDate: 'date',
      endDate: 'date?',
      renewalDate: 'date',
      autoRenew: 'bool',
      status: 'string',
      platform: 'string',
      paymentMethod: 'string',
      notes: 'string?',
      createdAt: 'date',
      updatedAt: 'date'
    }
  };
}
```

#### 4.1.2 索引设计
```typescript
// 为常用查询字段创建索引
const indexes: Realm.Index[] = [
  { name: 'subscription_user_id', properties: ['userId'] },
  { name: 'subscription_category_id', properties: ['categoryId'] },
  { name: 'subscription_status', properties: ['status'] },
  { name: 'subscription_renewal_date', properties: ['renewalDate'] }
];
```

### 4.2 AsyncStorage数据结构
```typescript
// 存储键名定义
const STORAGE_KEYS = {
  CURRENT_USER: 'current_user_id', // 当前登录用户ID
  APP_SETTINGS: 'app_settings', // 应用全局设置
  ONBOARDING_COMPLETED: 'onboarding_completed' // 是否完成引导页
};

// 应用全局设置
interface AppSettings {
  language: string; // 应用语言，默认'zh-CN'
  analyticsEnabled: boolean; // 是否启用数据分析
  crashReportingEnabled: boolean; // 是否启用崩溃报告
}
```

## 五、数据验证规则

### 5.1 验证原则
1. **输入验证**：所有用户输入必须经过验证
2. **类型安全**：使用TypeScript类型系统确保类型安全
3. **业务规则**：验证数据是否符合业务逻辑
4. **数据完整性**：确保数据的完整性和一致性
5. **安全防护**：防止SQL注入、XSS等安全漏洞

### 5.2 用户数据验证
```typescript
// src/utils/validationUtils.ts
import * as yup from 'yup';

// 用户信息验证Schema
export const userSchema = yup.object().shape({
  id: yup.string().required('用户ID不能为空').uuid('用户ID格式不正确'),
  username: yup.string()
    .required('用户名不能为空')
    .min(2, '用户名至少2个字符')
    .max(50, '用户名最多50个字符')
    .matches(/^[a-zA-Z0-9_\u4e00-\u9fa5]+$/, '用户名只能包含字母、数字、下划线和中文'),
  email: yup.string()
    .optional()
    .email('邮箱格式不正确')
    .max(100, '邮箱最多100个字符'),
  avatar: yup.string().optional().max(500, '头像路径过长'),
  theme: yup.string()
    .required('主题设置不能为空')
    .oneOf(['light', 'dark', 'system'], '主题设置值不正确'),
  currency: yup.string()
    .required('货币类型不能为空')
    .matches(/^[A-Z]{3}$/, '货币类型格式不正确，如CNY、USD'),
  reminderSettings: reminderSettingsSchema.required('提醒设置不能为空'),
  createdAt: yup.date().required('创建时间不能为空'),
  updatedAt: yup.date().required('更新时间不能为空'),
});

// 提醒设置验证Schema
export const reminderSettingsSchema = yup.object().shape({
  enabled: yup.boolean().required('提醒开关不能为空'),
  advanceDays: yup.number()
    .required('提前天数不能为空')
    .integer('提前天数必须为整数')
    .min(1, '提前天数至少1天')
    .max(7, '提前天数最多7天'),
  repeatInterval: yup.string()
    .required('重复间隔不能为空')
    .oneOf(['none', 'daily', 'weekly'], '重复间隔值不正确'),
  notificationChannels: yup.array()
    .of(notificationChannelSchema)
    .required('通知渠道不能为空'),
});

// 通知渠道验证Schema
export const notificationChannelSchema = yup.object().shape({
  type: yup.string()
    .required('通知类型不能为空')
    .oneOf(['local'], '通知类型不正确'),
  enabled: yup.boolean().required('通知开关不能为空'),
  sound: yup.boolean().required('声音开关不能为空'),
  vibration: yup.boolean().required('震动开关不能为空'),
});
```

### 5.3 订阅数据验证
```typescript
// 订阅信息验证Schema
export const subscriptionSchema = yup.object().shape({
  id: yup.string().required('订阅ID不能为空').uuid('订阅ID格式不正确'),
  userId: yup.string().required('用户ID不能为空').uuid('用户ID格式不正确'),
  name: yup.string()
    .required('订阅名称不能为空')
    .min(1, '订阅名称至少1个字符')
    .max(100, '订阅名称最多100个字符'),
  description: yup.string().optional().max(500, '描述最多500个字符'),
  categoryId: yup.string().required('分类ID不能为空').uuid('分类ID格式不正确'),
  tags: yup.array()
    .of(yup.string().max(50, '标签最多50个字符'))
    .max(10, '最多10个标签'),
  type: yup.string()
    .required('订阅周期不能为空')
    .oneOf(['monthly', 'yearly', 'quarterly', 'weekly', 'one-time'], '订阅周期值不正确'),
  price: yup.number()
    .required('订阅费用不能为空')
    .positive('订阅费用必须大于0')
    .max(999999.99, '订阅费用超出范围'),
  currency: yup.string()
    .required('货币类型不能为空')
    .matches(/^[A-Z]{3}$/, '货币类型格式不正确，如CNY、USD'),
  billingDate: yup.date().required('计费日期不能为空'),
  startDate: yup.date().required('开始日期不能为空'),
  endDate: yup.date().optional().min(yup.ref('startDate'), '结束日期不能早于开始日期'),
  renewalDate: yup.date().required('续费日期不能为空'),
  autoRenew: yup.boolean().required('自动续费开关不能为空'),
  status: yup.string()
    .required('订阅状态不能为空')
    .oneOf(['active', 'cancelled', 'expired'], '订阅状态值不正确'),
  platform: yup.string()
    .required('订阅平台不能为空')
    .max(50, '平台名称最多50个字符'),
  paymentMethod: yup.string()
    .required('支付方式不能为空')
    .max(50, '支付方式最多50个字符'),
  notes: yup.string().optional().max(1000, '备注最多1000个字符'),
  createdAt: yup.date().required('创建时间不能为空'),
  updatedAt: yup.date().required('更新时间不能为空'),
});

// 订阅创建验证Schema（不包含自动生成的字段）
export const createSubscriptionSchema = subscriptionSchema.omit([
  'id',
  'userId',
  'createdAt',
  'updatedAt',
]);
```

### 5.4 分类数据验证
```typescript
// 分类信息验证Schema
export const categorySchema = yup.object().shape({
  id: yup.string().required('分类ID不能为空').uuid('分类ID格式不正确'),
  userId: yup.string().required('用户ID不能为空').uuid('用户ID格式不正确'),
  name: yup.string()
    .required('分类名称不能为空')
    .min(1, '分类名称至少1个字符')
    .max(50, '分类名称最多50个字符'),
  description: yup.string().optional().max(200, '描述最多200个字符'),
  color: yup.string()
    .required('分类颜色不能为空')
    .matches(/^#[0-9A-Fa-f]{6}$/, '颜色格式不正确，如#FF0000'),
  icon: yup.string()
    .required('分类图标不能为空')
    .max(50, '图标名称最多50个字符'),
  isDefault: yup.boolean().required('是否默认分类不能为空'),
  createdAt: yup.date().required('创建时间不能为空'),
  updatedAt: yup.date().required('更新时间不能为空'),
});

// 分类创建验证Schema
export const createCategorySchema = categorySchema.omit([
  'id',
  'userId',
  'createdAt',
  'updatedAt',
]);
```

### 5.5 标签数据验证
```typescript
// 标签信息验证Schema
export const tagSchema = yup.object().shape({
  id: yup.string().required('标签ID不能为空').uuid('标签ID格式不正确'),
  userId: yup.string().required('用户ID不能为空').uuid('用户ID格式不正确'),
  name: yup.string()
    .required('标签名称不能为空')
    .min(1, '标签名称至少1个字符')
    .max(50, '标签名称最多50个字符'),
  color: yup.string()
    .required('标签颜色不能为空')
    .matches(/^#[0-9A-Fa-f]{6}$/, '颜色格式不正确，如#FF0000'),
  createdAt: yup.date().required('创建时间不能为空'),
  updatedAt: yup.date().required('更新时间不能为空'),
});

// 标签创建验证Schema
export const createTagSchema = tagSchema.omit([
  'id',
  'userId',
  'createdAt',
  'updatedAt',
]);
```

### 5.6 验证工具函数
```typescript
// 验证工具类
export class ValidationUtils {
  /**
   * 验证用户数据
   */
  static validateUser(data: any): User {
    try {
      return userSchema.validateSync(data, { abortEarly: false });
    } catch (error) {
      if (error instanceof yup.ValidationError) {
        throw new ValidationError('用户数据验证失败', error.errors);
      }
      throw error;
    }
  }

  /**
   * 验证订阅数据
   */
  static validateSubscription(data: any): Subscription {
    try {
      return subscriptionSchema.validateSync(data, { abortEarly: false });
    } catch (error) {
      if (error instanceof yup.ValidationError) {
        throw new ValidationError('订阅数据验证失败', error.errors);
      }
      throw error;
    }
  }

  /**
   * 验证分类数据
   */
  static validateCategory(data: any): Category {
    try {
      return categorySchema.validateSync(data, { abortEarly: false });
    } catch (error) {
      if (error instanceof yup.ValidationError) {
        throw new ValidationError('分类数据验证失败', error.errors);
      }
      throw error;
    }
  }

  /**
   * 验证标签数据
   */
  static validateTag(data: any): Tag {
    try {
      return tagSchema.validateSync(data, { abortEarly: false });
    } catch (error) {
      if (error instanceof yup.ValidationError) {
        throw new ValidationError('标签数据验证失败', error.errors);
      }
      throw error;
    }
  }

    /**
   * 验证日期范围
   */
  static validateDateRange(startDate: Date, endDate?: Date): boolean {
    if (endDate && endDate < startDate) {
      throw new ValidationError('结束日期不能早于开始日期');
    }
    return true;
  }

  /**
   * 验证货币金额
   */
  static validateAmount(amount: number): boolean {
    if (amount <= 0 || amount > 999999.99) {
      throw new ValidationError('金额必须在0到999999.99之间');
    }
    return true;
  }

  /**
   * 验证颜色格式
   */
  static validateColor(color: string): boolean {
    const colorRegex = /^#[0-9A-Fa-f]{6}$/;
    if (!colorRegex.test(color)) {
      throw new ValidationError('颜色格式不正确，如#FF0000');
    }
    return true;
  }
}

// 自定义验证错误类
export class ValidationError extends Error {
  constructor(message: string, public details?: string[]) {
    super(message);
    this.name = 'ValidationError';
  }
}
```

### 5.7 Repository层验证集成
```typescript
// src/repositories/SubscriptionRepository.ts
export class SubscriptionRepository {
  /**
   * 创建订阅
   */
  async create(subscription: Omit<Subscription, 'id' | 'createdAt' | 'updatedAt'>): Promise<Subscription> {
    // 验证数据
    const validatedData = ValidationUtils.validateSubscription(subscription);

    // 验证日期范围
    ValidationUtils.validateDateRange(validatedData.startDate, validatedData.endDate);

    // 验证金额
    ValidationUtils.validateAmount(validatedData.price);

    // 生成ID和时间戳
    const newSubscription: Subscription = {
      ...validatedData,
      id: generateUUID(),
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    // 保存到数据库
    return this.realm.write(() => {
      return this.realm.create('Subscription', newSubscription);
    });
  }

  /**
   * 更新订阅
   */
  async update(id: string, subscription: Partial<Subscription>): Promise<Subscription> {
    // 查找现有订阅
    const existing = await this.getById(id);
    if (!existing) {
      throw new Error('订阅不存在');
    }

    // 合并数据
    const mergedData = { ...existing, ...subscription };

    // 验证合并后的数据
    const validatedData = ValidationUtils.validateSubscription(mergedData);

    // 更新数据库
    return this.realm.write(() => {
      const updated = this.realm.create('Subscription', {
        ...validatedData,
        updatedAt: new Date(),
      }, true);
      return updated;
    });
  }
}
```

## 六、数据操作接口

### 6.1 用户数据操作
```typescript
interface UserRepository {
  create(user: Omit<User, 'id' | 'createdAt' | 'updatedAt'>): Promise<User>;
  getById(id: string): Promise<User | null>;
  update(id: string, user: Partial<User>): Promise<User>;
  delete(id: string): Promise<void>;
  getCurrentUser(): Promise<User | null>;
  setCurrentUser(userId: string): Promise<void>;
}
```

### 6.2 订阅数据操作
```typescript
interface SubscriptionRepository {
  create(subscription: Omit<Subscription, 'id' | 'createdAt' | 'updatedAt'>): Promise<Subscription>;
  getById(id: string): Promise<Subscription | null>;
  getAllByUserId(userId: string): Promise<Subscription[]>;
  getByCategoryId(userId: string, categoryId: string): Promise<Subscription[]>;
  getByStatus(userId: string, status: string): Promise<Subscription[]>;
  getExpiringSoon(userId: string, days: number): Promise<Subscription[]>;
  update(id: string, subscription: Partial<Subscription>): Promise<Subscription>;
  delete(id: string): Promise<void>;
  batchDelete(ids: string[]): Promise<void>;
}
```

### 6.3 分类数据操作
```typescript
interface CategoryRepository {
  create(category: Omit<Category, 'id' | 'createdAt' | 'updatedAt'>): Promise<Category>;
  getById(id: string): Promise<Category | null>;
  getAllByUserId(userId: string): Promise<Category[]>;
  update(id: string, category: Partial<Category>): Promise<Category>;
  delete(id: string): Promise<void>;
  getDefaultCategories(): Promise<Category[]>;
}
```

## 七、错误数据处理策略

### 7.1 错误处理原则
1. **统一错误处理**：使用统一的错误处理机制
2. **错误分类**：区分不同类型的错误（验证错误、数据库错误、网络错误等）
3. **错误日志**：记录错误日志，便于问题排查
4. **用户友好**：向用户展示友好的错误提示
5. **错误恢复**：提供错误恢复机制

### 7.2 错误类型定义
```typescript
// 错误类型枚举
export enum ErrorType {
  VALIDATION_ERROR = 'VALIDATION_ERROR',      // 验证错误
  DATABASE_ERROR = 'DATABASE_ERROR',          // 数据库错误
  NETWORK_ERROR = 'NETWORK_ERROR',            // 网络错误
  NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',        // 资源不存在错误
  PERMISSION_ERROR = 'PERMISSION_ERROR',      // 权限错误
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',            // 未知错误
}

// 自定义错误基类
export class AppError extends Error {
  constructor(
    message: string,
    public type: ErrorType,
    public code?: string,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// 验证错误
export class ValidationError extends AppError {
  constructor(message: string, details?: string[]) {
    super(message, ErrorType.VALIDATION_ERROR, 'VALIDATION_FAILED', details);
    this.name = 'ValidationError';
  }
}

// 数据库错误
export class DatabaseError extends AppError {
  constructor(message: string, details?: any) {
    super(message, ErrorType.DATABASE_ERROR, 'DATABASE_ERROR', details);
    this.name = 'DatabaseError';
  }
}

// 网络错误
export class NetworkError extends AppError {
  constructor(message: string, details?: any) {
    super(message, ErrorType.NETWORK_ERROR, 'NETWORK_ERROR', details);
    this.name = 'NetworkError';
  }
}

// 资源不存在错误
export class NotFoundError extends AppError {
  constructor(resource: string, id: string) {
    super(
      `${resource}不存在`,
      ErrorType.NOT_FOUND_ERROR,
      'NOT_FOUND',
      { resource, id }
    );
    this.name = 'NotFoundError';
  }
}

// 权限错误
export class PermissionError extends AppError {
  constructor(message: string) {
    super(message, ErrorType.PERMISSION_ERROR, 'PERMISSION_DENIED');
    this.name = 'PermissionError';
  }
}
```

### 7.3 错误处理中间件
```typescript
// 错误处理工具类
export class ErrorHandler {
  /**
   * 处理错误并返回用户友好的错误信息
   */
  static handleError(error: unknown): string {
    if (error instanceof AppError) {
      return this.getUserFriendlyMessage(error);
    } else if (error instanceof Error) {
      return error.message;
    } else {
      return '发生未知错误，请稍后重试';
    }
  }

  /**
   * 获取用户友好的错误信息
   */
  private static getUserFriendlyMessage(error: AppError): string {
    switch (error.type) {
      case ErrorType.VALIDATION_ERROR:
        return error.message || '输入数据不正确，请检查后重试';
      case ErrorType.DATABASE_ERROR:
        return '数据保存失败，请稍后重试';
      case ErrorType.NETWORK_ERROR:
        return '网络连接失败，请检查网络后重试';
      case ErrorType.NOT_FOUND_ERROR:
        return error.message || '请求的资源不存在';
      case ErrorType.PERMISSION_ERROR:
        return error.message || '没有权限执行此操作';
      default:
        return '发生未知错误，请稍后重试';
    }
  }

  /**
   * 记录错误日志
   */
  static logError(error: unknown, context?: string): void {
    const errorInfo = {
      timestamp: new Date().toISOString(),
      context,
      error: error instanceof Error ? {
        name: error.name,
        message: error.message,
        stack: error.stack,
      } : error,
    };

    // 在开发环境输出到控制台
    if (process.env.NODE_ENV === 'development') {
      console.error('[Error]', errorInfo);
    }

    // 在生产环境发送到日志服务（后续版本）
    if (process.env.NODE_ENV === 'production') {
      // TODO: 发送到日志服务
    }
  }

  /**
   * 显示错误提示
   */
  static showError(error: unknown): void {
    const message = this.handleError(error);
    // TODO: 使用Toast或Alert显示错误提示
    Alert.alert('错误', message);
  }
}
```

### 7.4 Repository层错误处理
```typescript
// src/repositories/BaseRepository.ts
export abstract class BaseRepository<T> {
  protected realm: Realm;

  constructor(realm: Realm) {
    this.realm = realm;
  }

  /**
   * 执行数据库操作并处理错误
   */
  protected async executeOperation<R>(
    operation: () => R,
    errorMessage: string = '操作失败'
  ): Promise<R> {
    try {
      return operation();
    } catch (error) {
      ErrorHandler.logError(error, this.constructor.name);
      
      if (error instanceof AppError) {
        throw error;
      }
      
      throw new DatabaseError(errorMessage, error);
    }
  }

  /**
   * 查找实体，不存在时抛出错误
   */
  protected async findOrThrow(id: string, entityName: string): Promise<T> {
    const entity = await this.getById(id);
    if (!entity) {
      throw new NotFoundError(entityName, id);
    }
    return entity;
  }

  /**
   * 抽象方法，子类必须实现
   */
  abstract getById(id: string): Promise<T | null>;
}

// src/repositories/SubscriptionRepository.ts
export class SubscriptionRepository extends BaseRepository<Subscription> {
  /**
   * 创建订阅
   */
  async create(subscription: Omit<Subscription, 'id' | 'createdAt' | 'updatedAt'>): Promise<Subscription> {
    return this.executeOperation(async () => {
      // 验证数据
      const validatedData = ValidationUtils.validateSubscription(subscription);

      // 生成ID和时间戳
      const newSubscription: Subscription = {
        ...validatedData,
        id: generateUUID(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      // 保存到数据库
      return this.realm.write(() => {
        return this.realm.create('Subscription', newSubscription);
      });
    }, '创建订阅失败');
  }

  /**
   * 更新订阅
'   */
  async update(id: string, subscription: Partial<Subscription>): Promise<Subscription> {
    return this.executeOperation(async () => {
      // 查找现有订阅
      const existing = await this.findOrThrow(id, '订阅');

      // 合并数据
      const mergedData = { ...existing, ...subscription };

      // 验证合并后的数据
      const validatedData = ValidationUtils.validateSubscription(mergedData);

      // 更新数据库
      return this.realm.write(() => {
        const updated = this.realm.create('Subscription', {
          ...validatedData,
          updatedAt: new Date(),
        }, true);
        return updated;
      });
    }, '更新订阅失败');
  }

    /**
   * 删除订阅
   */
  async delete(id: string): Promise<void> {
    return this.executeOperation(async () => {
      // 查找订阅
      await this.findOrThrow(id, '订阅');

      // 删除订阅
      this.realm.write(() => {
        const subscription = this.realm.objectForPrimaryKey('Subscription', id);
        if (subscription) {
          this.realm.delete(subscription);
        }
      });
    }, '删除订阅失败');
  }

  /**
   * 获取订阅
   */
  async getById(id: string): Promise<Subscription | null> {
    return this.executeOperation(() => {
      return this.realm.objectForPrimaryKey('Subscription', id) || null;
    }, '获取订阅失败');
  }
}
```

### 7.5 UI层错误处理
```typescript
// src/hooks/useErrorHandler.ts
import { useCallback } from 'react';
import { Alert } from 'react-native';

export const useErrorHandler = () => {
  const handleError = useCallback((error: unknown) => {
    ErrorHandler.logError(error);
    ErrorHandler.showError(error);
  }, []);

  const handleAsyncError = useCallback(async (
    asyncFn: () => Promise<void>,
    onSuccess?: () => void
  ) => {
    try {
      await asyncFn();
      onSuccess?.();
    } catch (error) {
      handleError(error);
    }
  }, [handleError]);

  return { handleError, handleAsyncError };
};

// 使用示例
const SubscriptionForm = () => {
  const { handleAsyncError } = useErrorHandler();

  const handleSubmit = () => {
    handleAsyncError(
      async () => {
        await subscriptionRepository.create(subscriptionData);
      },
      () => {
        Alert.alert('成功', '订阅创建成功');
      }
    );
  };

  return <Button onPress={handleSubmit}>提交</Button>;
};
```

### 7.6 错误恢复策略
```typescript
// 错误恢复策略
export class ErrorRecovery {
  /**
   * 重试操作
   */
  static async retry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    let lastError: Error;

    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        if (i < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError!;
  }

  /**
   * 回退到默认值
   */
  static fallback<T>(operation: () => T, defaultValue: T): T {
    try {
      return operation();
    } catch (error) {
      ErrorHandler.logError(error);
      return defaultValue;
    }
  }

  /**
   * 数据库连接恢复
   */
  static async recoverDatabase(): Promise<Realm> {
    try {
      // 尝试重新连接数据库
      return await Realm.open({
        path: 'TingSub.realm',
        schema: [User, Subscription, Category, Tag],
        schemaVersion: 1,
      });
    } catch (error) {
      // 如果连接失败，尝试删除旧数据库并重新创建
      try {
        Realm.deleteFile({ path: 'TingSub.realm' });
        return await Realm.open({
          path: 'TingSub.realm',
          schema: [User, Subscription, Category, Tag],
          schemaVersion: 1,
        });
      } catch (retryError) {
        throw new DatabaseError('数据库恢复失败', retryError);
      }
    }
  }
}
```

### 7.7 错误监控（后续版本）
```typescript
// 错误监控服务（后续版本实现）
export class ErrorMonitoring {
  /**
   * 初始化错误监控
   */
  static initialize(): void {
    // TODO: 集成Sentry或其他错误监控服务
    // Sentry.init({
    //   dsn: process.env.SENTRY_DSN,
    //   environment: process.env.NODE_ENV,
    // });
  }

  /**
   * 捕获全局错误
   */
  static captureException(error: Error): void {
    // TODO: 发送到错误监控服务
    // Sentry.captureException(error);
  }

  /**
   * 捕获用户行为
   */
  static captureUserAction(action: string, data?: any): void {
    // TODO: 记录用户行为
    // Sentry.addBreadcrumb({
    //   category: 'user',
    //   message: action,
    //   data,
    // });
  }
}
```

## 八、数据迁移策略

### 8.1 版本迁移
```typescript
// Realm数据库版本迁移示例
const migration: Realm.Migration = (oldRealm, newRealm) => {
  if (oldRealm.schemaVersion < 1) {
    // 版本1：添加用户主题设置
    const oldUsers = oldRealm.objects('User');
    const newUsers = newRealm.objects('User');
    for (let i = 0; i < oldUsers.length; i++) {
      newUsers[i].theme = 'system';
    }
  }
  if (oldRealm.schemaVersion < 2) {
    // 版本2：添加订阅状态字段
    const oldSubscriptions = oldRealm.objects('Subscription');
    const newSubscriptions = newRealm.objects('Subscription');
    for (let i = 0; i < oldSubscriptions.length; i++) {
      newSubscriptions[i].status = 'active';
    }
  }
};
```

### 8.2 数据导出与导入
```typescript
interface DataExportService {
  exportUserData(userId: string): Promise<Blob>; // 导出用户数据为JSON格式
  importUserData(data: Blob): Promise<void>; // 导入用户数据
  exportSubscriptions(userId: string, format: 'csv' | ''json'): Promise<Blob>; // 导出订阅数据
}
```

## 九、数据安全

### 9.1 数据加密
- **Realm数据库加密**：使用Realm的加密功能，对本地数据库进行加密存储
- **敏感数据加密**：对用户敏感数据（如邮箱、支付信息等）进行加密存储
- **传输加密**：后续版本云端同步时将使用HTTPS加密传输

### 9.2 数据备份
- **本地备份**：支持用户手动导出数据进行本地备份
- **云端备份**：不考虑

## 十、附录

### 10.1 数据类型映射
| TypeScript类型 | Realm类型 | SQLite类型 |
| --- | --- | --- |
| string | string | TEXT |
| number | int/double | INTEGER/REAL |
| boolean | bool | INTEGER |
| Date | date | TEXT |
| Array | list | TEXT（JSON格式存储） |
| Object | object | TEXT（JSON格式存储） |

### 8.2 参考资料
- 《Realm 官方文档》
- 《TypeScript 官方文档》
- 《React Native AsyncStorage 官方文档》